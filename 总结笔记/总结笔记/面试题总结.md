**一、 简述一下线程和进程的区别？**

1. 进程间相互独立，每个进程都独享一块内存空间；进程中可以有多个线程，所有线程共享进程的资源。
2. 进程间通信需要IPC机制，而线程间通信可以通过全局变量等手段。但是需要注意使用线程安全以保证数据的一致性。
3. 进程是资源分配的基本单位而线程是cpu调度的基本单位。进程比线程更加健壮但是线程间切换比进程间切换效率高得多。

**二、 现有100个String对象，如何高效的把他们首尾相连在一起？**

如果不注重线程安全，可以使用StringBuilder，否则可使用StringBuffer。

**三、 判断如下代码：**

	class A{}
	class B extends A{
	
	}
	class C extends A{}

    A p0 = new A();
    B p1 = new B();
    C p2 = new C();
    A p3 = new B();
    A p4 = new C();

	Which three are vaild?

    A、p0 = p1;
    B、p1 = p2;
    C、p2 = p4;
	D、p2 = p1;
    E、p1 = (B) p3;
    F、p2 = (C) p4;

**答案：**

A E F

**四、 View的onTouchEvent与onInterceptTouchEvent的区别是什么？**
	

1. `onTouchEvent()`用来处理触摸事件，而`onInterceptTouchEvent()`用来处理拦截触摸事件。
2. `onTouchEvent()`是View中的方法，而`onInterceptTouchEvent()`是ViewGroup中的方法。
3. 如果是可点击的View,`onTouchEvent()`默认返回true，而`onInterceptTouchEvent()`默认返回false;

**五、 在同一个类中定义了如下2个函数，有没有问题？**

	Int getValue(String key);
	Float getValue(String key);

**答案：**

这里有问题。
重载有三个必要条件：1. 参数个数不同   2.参数类型不同 3.参数顺序不同。<br>

在这里，不满足任何一种条件，所以编译器会报错。

**六、 看看下面的代码有没有问题？**

	Public class Test{
		Public static String sName="a”;

		Public static void changeName(){
			this.sName="b";
		}
	}

**答案：**
有问题。静态方法`changeName()`是类方法，而this是属于对象的操作符，表示对象本身。在静态方法中不能保证this已经存在，所以this不能用在静态方法中。

**七、 简述如何实现后台程序的运行进度提示，如何在后台线程中更新前台的控件？**

1. Notification有一个`setProgress()`可以用来显示进度，所以这里可以使用AsyncTask+Notification实现后台程序的运行进度提示；
2. 在后台线程更新前台控件的方法有：
	1. 使用handler机制在主线程中更新UI。
	2. 如果是Activity中开启的后台线程，可以使用`runOnUiThread()`方法。
	3. 如果是在View中开启的后台线程，可以使用`post()`方法。

**八、 写一个Singleton（单例模式）**

1. 静态内部类的单例模式：

		public class Singleton {
			private Singleton(){}
		
			public static Singleton getInstance(){
		    	return SingletonHolder.instance;
			}
		
		    private static class SingletonHolder{
		        private static final Singleton instance = new Singleton();
		    }
		}

	>优点：延迟加载，线程安全，性能较好。

2. 枚举单例模式：

		public enum EnumSingleton {
		    //定义了一个枚举的元素，它就是Singleton的一个实例。
		    INSTANCE;
		}
	>优点：写法简单，线程安全，性能较好。但是不能延迟加载。

**九、 一组从小到大的数据存储在ArrayList中，写个函数通过折半查找迅速的找到对应索引的值。**

    public static int getIndex(ArrayList list,int a){
        int left = 0;
		//list.size()是个数，索引需要减1
        int right = list.size() - 1;
        int middle;

        while (left <= right){
            middle = (left + right)/2;

            if ( a == (int)list.get(middle)){
                return middle;
            }else if (a > (int)list.get(middle)){
                left = middle+1;
            }else {
                right = middle-1;
            }
        }
        return -1;
    }

**十、 两个升序整型数组A和B，元素个数分别为m和n，将数组B合并到数组A中，数组A保持升序，请用java实现该算法。**

	//合并到数组A，意思是A有足够的容量？
    public static int[] mergeArray(int[] arr1,int m,int[] arr2,int n){
        int merge_size = m + n -1;
        m--;
        n--;
        while ( m >= 0 && n>= 0){
            if (arr1[m] >= arr2[n]){
                arr1[merge_size] = arr1[m];
                m--;
            }else {
                arr1[merge_size] = arr2[n];
                n--;
            }
            merge_size--;
        }
        while (n >= 0){
            arr1[merge_size] = arr2[n];
            n--;
            merge_size--;
        }
        return arr1;
    }

**十一、 写一个算法，实现单链表的反转。**

这里，由于涉及到链表，所以自己先实现了一个，不算在算法里。

	public class Node {
	    public int data;
	    public Node next;
	
	    Node(int data){
	        this.data = data;
	    }
	}

	public class LinkList {
	    public Node head;
	
	    LinkList(){
	        head = null;
	    }
	
	    public void addFirstNode(int data){
	        Node node = new Node(data);
	        node.next = head;
	        head = node;
	    }
	}

算法实现如下：

	public static Node resetList(Node node){
        //从头开始反转，一直到最后一个，时间复杂度为n
        if (node == null || node.next == null){
            return node;
        }
        Node current = node;
        Node temp = null;
        Node newNode = null;
        while (current != null){
            temp = current;
            current = current.next;
            temp.next = newNode;
            newNode = temp;
        }
        return newNode;
    }

**十一、 实现一段代码统计给定目录中的文件数，注意目录中可能包括子目录。**

	//使用递归
	public static int getFileCount(File path){
        int count = 0;
        File[] files = path.listFiles();
        for (File file:files
             ) {
            if (file.isDirectory()){
                count += getFileCount(file);
            }else {
                count += 1;
            }
        }
        return count;
    }