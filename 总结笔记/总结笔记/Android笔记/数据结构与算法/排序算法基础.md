
|  排序算法| 平均时间复杂度 |
| :------: |:-------:| 
| 冒泡排序 | O(n2) |
| 选择排序 | O(n2) |
| 插入排序 | O(n2) |
| 希尔排序 | O(n1.3) |
| 快速排序 | O(N*logN) |
| 归并排序 | O(N*logN) |
| 堆排序 | O(N*logN) |
| 基数排序 | O(d(n+r)) |

##一、冒泡排序（BubbleSort）
**1. 基本思想：**两个数比较大小，较大的数下沉，较小的数冒起来。

**2. 过程：**

- 比较相邻的两个数据，如果第二个数较小，就交换位置。
- 从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了
- 继续重复上述过程，依次将第2.3...n-1个最小数排好位置。

**3. java代码实现：**

	public static void BubbleSort(int[] arr){
       int temp;
       boolean flag;
       for (int i = 0;i < arr.length-1;i++){
           flag = false;
           for (int j = 0;j < arr.length-i-1;j++){
               if (arr[j] > arr[j+1]){
                   temp = arr[j];
                   arr[j] = arr[j+1];
                   arr[j+1] = temp;
                   flag = true;
               }
           }
           if (!flag) break;
       }
	}	

**4. 时间复杂度：**

- 平均时间复杂度：O(n2)
- 最好情况：O(n)
- 最坏情况：O(n2)
- 空间复杂度：O(1)

##二、选择排序（SelctionSort）
**1. 基本思想：**每次循环选择最小的数与第**i**个数交换。

**2. 过程：**

在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；<br>
第二次遍历n-2个数，找到最小的数值与第二个元素交换；<br>
。。。。。。<br>
第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。

**3. java代码实现：**
		
	public static void SelctionSort(int[] arr){
        for (int i= 0;i < arr.length-1;i++){
            int minIndex = i;
            for (int j = i+1;j < arr.length;j++){
                if (arr[minIndex] > arr[j]){
                    minIndex = j;
                }
            }
            if (minIndex != i){
                int temp;
                temp = arr[minIndex];
                arr[minIndex] = arr[i];
                arr[i] = temp;
            }
        }
    }

**4. 时间复杂度：**

- 平均时间复杂度：O(n2)
- 最好情况：O(n2)
- 最坏情况：O(n2)
- 空间复杂度：O(1)

##三、插入排序（InsertionSort）
**1. 基本思想：**在要排序的一组数中，假定前面n-1个数已排好，将第n个数插入。

**2. 过程：**

在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

**3. java代码实现：**
		
	public static void InsertionSort(int[] arr){
        for (int i = 1;i < arr.length;i++){
            int insert = arr[i];
            int j;
            for (j = i-1;j >= 0;j--){
                if (insert < arr[j]){
                    arr[j+1] = arr[j];
                }else {
                    break;
                }
            }
            arr[j+1] = insert;
        }
    }

**4. 时间复杂度：**

- 平均时间复杂度：O(n2)
- 最好情况：O(n)
- 最坏情况：O(n2)
- 空间复杂度：O(1)

##四、希尔排序（ShellSort）
**1. 基本思想：**如果数据序列基本有序，使用插入排序会更加高效。

**2. 过程：**

在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。<br>
然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。

**3. java代码实现：**
		
	public static void ShellSort(int[] arr){
        int incre = arr.length;
        while (true){
            incre = incre/2;
            for (int i = 0;i < incre;i++){
                for (int j = i + incre;j < arr.length ; j += incre){
                    int temp = arr[j];
                    int k;
                    for ( k = j - incre; k >= i; k -= incre){
                        if (temp < arr[k]){
                            arr[k + incre] = arr[k];
                        }else {
                            break;
                        }
                    }
                    arr[k + incre] = temp;
                }
            }
            if (incre == 1){
                break;
            }
        }
    }

**4. 时间复杂度：**

- 平均时间复杂度：O(n1.3)
- 最好情况：O(n)
- 最坏情况：O(n2)
- 空间复杂度：O(1)

##五、快速排序（QuickSort）
**1. 基本思想：**分治法,递归。

**2. 过程：**

先从数列中取出一个数作为key值；<br>
将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；<br>
对左右两个小数列重复第二步，直至各区间只有1个数。<br>

**3. java代码实现：**
		
	public static void QuickSort(int[] arr,int l,int r){
        if (l >= r){
            return;
        }
        int i = l;int j = r;int key = arr[l];

        while (i < j){
            while (i < j && arr[j] >= key){
                j--;
            }
            if (i < j){
                arr[i] = arr[j];
                i++;
            }
            while (i < j && arr[i] < key){
                i ++;
            }
            if (i < j){
                arr[j] = arr[i];
                j -- ;
            }
        }
        arr[i] = key;
        QuickSort(arr,l,i-1);
        QuickSort(arr,i+1,r);
    }


**4. 时间复杂度：**

key值的选取可以有多种形式，例如中间数或者随机数，分别会对算法的复杂度产生不同的影响。

- 平均时间复杂度：O(nlog2n)
- 最好情况：O(nlog2n)
- 最坏情况：O(n2)
- 空间复杂度：O(nlog2n)

##六、归并排序（MergeSort）
**1. 基本思想：**归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。

**2. 过程：**

将数组分成2组A，B，如果这2组组内的数据都是有序的，那么就可以很方便的将这2组数据进行排序。如何让这2组组内数据有序了？<br>
可以将A，B组各自再分成2组。依次类推，当分出来的小组只有1个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的2个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。

**3. java代码实现：**
		
	public static void merge_sort(int a[],int first,int last){
        if (first < last){
            int middle = (first + last)/2;
            merge_sort(a,first,middle);
            merge_sort(a,middle+1,last);
            mergeArray(a,first,middle,last);
        }
    }

    private static void mergeArray(int[] a, int first, int middle, int last) {
        int f = first;
        int m = middle;
        int mAdd1 = middle+1;
        int l = last;
        int i = 0;
        int[] temp = new int[a.length];

        while (f<= m && mAdd1 <= l){
            if (a[f] <= a[mAdd1]){
                temp[i] = a[f];
                i++;
                f++;
            }else {
                temp[i] = a[mAdd1];
                i++;
                mAdd1++;
            }
        }
        while ( f<=m){
            temp[i] = a[f];
            f++;
            i++;
        }
        while (mAdd1 <= l){
            temp[i] = a[mAdd1];
            i++;
            mAdd1++;
        }
        for (int ii = 0;ii<i;ii++){
            a[first + ii] = temp[ii];
        }
    }


**4. 时间复杂度：**

归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。

- 平均时间复杂度：O(nlog2n)
- 最好情况：O(nlog2n)
- 最坏情况：O(nlog2n)
- 空间复杂度：O(1)

##七、堆排序（MergeSort）
**1. 基本思想：**最小堆，最大堆。

**2. 过程：**

构建最大堆。获取到最大值，与最后一位交换，前n-1位再次构建最大堆。。一直重复。。。


**3. java代码实现：**
		
	public static void MakeMinHeap(int a[],int n){
        for (int i = (n-1)/2 ; i>= 0; i--){
            MinHeapFixDown(a,i,n);
        }
    }

    private static void MinHeapFixDown(int[] a, int i, int n) {
        int j = 2 * i +1;
        int temp = 0;

        while (j<n){
            if (j+1<n && a[j+1] > a[j]){
                j++;
            }
            if (a[i] >= a[j]){
                break;
            }

            temp = a[i];
            a[i] = a[j];
            a[j] = temp;

            i = j;
            j = 2 * i +1;
        }
    }
    public static void MinHeap_Sort(int a[],int n){
        int temp = 0;
        MakeMinHeap(a,n);

        for (int i = n-1;i>0;i--){
            temp = a[0];
            a[0] = a[i];
            a[i] = temp;
            MinHeapFixDown(a,0,i);
        }
    }


**4. 时间复杂度：**

由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。

- 平均时间复杂度：O(nlog2n)
- 最好情况：O(nlog2n)
- 最坏情况：O(nlog2n)
- 空间复杂度：O(1)

##八、基数排序（RadixSort）
**1. 基本思想：**BinSort想法非常简单，首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。

**2. 过程：**

首先确定基数为10，数组的长度也就是10.每个数34都会在这10个数中寻找自己的位置。<br>
不同于BinSort会直接将数34放在数组的下标34处，基数排序是将34分开为3和4，第一轮排序根据最末位放在数组的下标4处，第二轮排序根据倒数第二位放在数组的下标3处，然后遍历数组即可。

**3. java代码实现：**
		
	public static void RadixSort(int a[],int temp[],int n,int k,int r,int cnt[]){
        for (int i = 0, rtok = 1; i <k ;i++,rtok = rtok *r){
            //初始化
            for(int j=0;j<r;j++){
                cnt[j] = 0;
            }

            for (int i2 :
                    cnt) {
                System.out.print(i2+" ");
            }
            System.out.println();

            //计算每个箱子的数字个数
            for(int j=0;j<n;j++){
                cnt[(a[j]/rtok)%r]++;
            }

            for (int i2 :
                    cnt) {
                System.out.print(i2+" ");
            }
            System.out.println();

            //cnt[j]的个数修改为前j个箱子一共有几个数字
            for(int j=1;j<r;j++){
                cnt[j] = cnt[j-1] + cnt[j];
            }


            for (int i2 :
                    cnt) {
                System.out.print(i2+" ");
            }
            System.out.println();

            for(int j = n-1;j>=0;j--){      //重点理解
                cnt[(a[j]/rtok)%r]--;
                temp[cnt[(a[j]/rtok)%r]] = a[j];
            }

            for (int i2 :
                    cnt) {
                System.out.print(i2+" ");
            }
            System.out.println();

            for(int j=0;j<n;j++){
                a[j] = temp[j];
            }

            for (int i2 :
                    a) {
                System.out.print(i2+" ");
            }
            System.out.println();

        }
    }


**4. 时间复杂度：**

由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。

- 平均时间复杂度：O(d(r+n))
- 最好情况：O(d(n+rd))
- 最坏情况：O(d(r+n))
- 空间复杂度：O(rd+n)