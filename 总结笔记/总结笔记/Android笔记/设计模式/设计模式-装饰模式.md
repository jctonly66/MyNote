##装饰模式
装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更加灵活。装饰模式是一种对象结构型模式。

###使用场景
1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
2. 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。

###UML结构图

![](http://i.imgur.com/8IrhkS5.png)

###示例代码：

**Person 抽象的人**

	public interface Person {
	    /**
	     * 穿着
	     */
	    void dressed();
	}
	Boy 具体组件 boy

	public class Boy implements Person {
	    @Override
	    public void dressed() {
	        System.out.println("穿内衣");
	    }
	}

**PersonCloth 装饰者，保留一个 Person 的引用**

	public abstract class PersonCloth implements Person {
	
	    protected Person person;
	
	    public PersonCloth(Person person) {
	        this.person = person;
	    }
	
	    @Override
	    public void dressed() {
	        person.dressed();
	    }
	}
**ExpensiveCloth 装饰者实现1**

	public class ExpensiveCloth extends PersonCloth {
	
	    public ExpensiveCloth(Person person) {
	        super(person);
	    }
	
	    @Override
	    public void dressed() {
	        super.dressed();
	        dressShirt();
	        dressJean();
	        dressShoes();
	    }
	
	    private void dressShirt() {
	        System.out.println("穿短袖");
	    }
	
	    private void dressJean() {
	        System.out.println("穿牛仔裤");
	    }
	
	    private void dressShoes() {
	        System.out.println("穿运动鞋");
	    }
	}
**CheapCloth 装饰者实现2**

	public class CheapCloth extends PersonCloth {
	
	    public CheapCloth(Person person) {
	        super(person);
	    }
	
	    private void dressShorts() {
	        System.out.println("穿短裤");
	    }
	
	    @Override
	    public void dressed() {
	        super.dressed();
	        dressShorts();
	    }
	}
**测试**

	public class DecoratorTest {
	    public static void main(String[] args) {
	        Person person = new Boy();
	
	        PersonCloth clothExpensive = new ExpensiveCloth(person);
	        clothExpensive.dressed();
	
	        // 输出：
	        // 穿内衣
			// 穿短袖
			// 穿牛仔裤
			// 穿运动鞋
	
	        PersonCloth clothCheap = new CheapCloth(person);
	        clothCheap.dressed();
	
	        // 输出：
	        // 穿内衣
			// 穿短裤
	    }
	}
>重点是接口中的对象。

###优点
1. 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。
2. 可以通过一种动态的方式来扩展一个对象的功能。
3. 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合。

###缺点
1. 比继承容易出错
